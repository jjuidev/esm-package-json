import { stat, readFile } from 'node:fs/promises';
import { join, extname } from 'node:path';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
async function isDirectory(cwd, path) {
  return stat(join(cwd, path)).then((result) => result.isDirectory()).catch(() => false);
}
__name(isDirectory, "isDirectory");
async function isFile(cwd, path) {
  return stat(join(cwd, path)).then((result) => !result.isDirectory()).catch(() => false);
}
__name(isFile, "isFile");
function isFunction(input) {
  return typeof input === "function";
}
__name(isFunction, "isFunction");
function getFilter(options) {
  if (!options.filter) {
    return /.*/;
  }
  if (Object.prototype.toString.call(options.filter) !== "[object RegExp]") {
    console.warn(
      `Plugin "esbuild-plugin-file-path-extensions": Options.filter must be a RegExp object, but gets an '${typeof options.filter}' type. 
This request will match ANY file!`
    );
    return /.*/;
  }
  return options.filter ?? /.*/;
}
__name(getFilter, "getFilter");
var builtins = null;
async function isBuiltin(path) {
  if (builtins === null) {
    builtins = (await import('node:module')).builtinModules;
  }
  return !path.startsWith(".") && (path.startsWith("node:") || builtins.includes(path));
}
__name(isBuiltin, "isBuiltin");
async function isDefinedDependency(path) {
  try {
    const packageJsonPath = join(process.cwd(), "package.json");
    const packageJson = JSON.parse(await readFile(packageJsonPath, { encoding: "utf-8" }));
    const { dependencies = {}, devDependencies = {}, peerDependencies = {} } = packageJson;
    const allDependencies = {
      ...dependencies,
      ...devDependencies,
      ...peerDependencies
    };
    return Object.keys(allDependencies).some((dep) => {
      const depParts = dep.split("/");
      const pathParts = path.split("/");
      return pathParts.slice(0, depParts.length).join("/") === dep;
    });
  } catch (error) {
    return false;
  }
}
__name(isDefinedDependency, "isDefinedDependency");
async function getIsEsm(build, options) {
  if (build.initialOptions.define?.TSUP_FORMAT === '"cjs"') {
    return false;
  }
  if (typeof options.esm === "undefined") {
    return build.initialOptions.define?.TSUP_FORMAT === '"esm"' || build.initialOptions.format === "esm";
  }
  if (typeof options.esm === "boolean") {
    return options.esm;
  }
  return isFunction(options.esm) ? options.esm(build.initialOptions) : options.esm;
}
__name(getIsEsm, "getIsEsm");
async function getEsmExtension(build, options) {
  if (typeof options.esmExtension === "undefined") {
    return "mjs";
  }
  if (typeof options.esmExtension === "string") {
    return options.esmExtension;
  }
  return isFunction(options.esmExtension) ? options.esmExtension(build.initialOptions) : options.esmExtension;
}
__name(getEsmExtension, "getEsmExtension");
async function getCjsExtension(build, options) {
  if (typeof options.cjsExtension === "undefined") {
    return "cjs";
  }
  if (typeof options.cjsExtension === "string") {
    return options.cjsExtension;
  }
  return isFunction(options.cjsExtension) ? options.cjsExtension(build.initialOptions) : options.cjsExtension;
}
__name(getCjsExtension, "getCjsExtension");
function pathExtIsJsLikeExtension(path) {
  const ext = extname(path);
  if (
    // Regular extensions
    ext === ".js" || ext === ".cjs" || ext === ".mjs" || // TypeScript extensions
    ext === ".ts" || ext === ".cts" || ext === ".mts" || // JSX JavaScript extensions
    ext === "jsx" || ext === ".cjsx" || ext === ".mjsx" || // JSX TypeScript extensions
    ext === ".tsx" || ext === ".ctsx" || ext === ".mtsx"
  ) {
    return true;
  }
  return false;
}
__name(pathExtIsJsLikeExtension, "pathExtIsJsLikeExtension");
async function handleResolve(args, build, options) {
  if (args.kind === "import-statement") {
    const isEsm = await getIsEsm(build, options);
    const esmExtension = await getEsmExtension(build, options);
    const cjsExtension = await getCjsExtension(build, options);
    if (typeof isEsm !== "boolean") {
      throw new TypeError(`isEsm must be a boolean, received ${typeof isEsm} (${isEsm})`);
    }
    if (typeof cjsExtension !== "string") {
      throw new TypeError(`cjsExtension must be a string, received ${typeof cjsExtension} (${cjsExtension})`);
    }
    if (typeof esmExtension !== "string") {
      throw new TypeError(`esmExtension must be a string, received ${typeof esmExtension} (${esmExtension})`);
    }
    if (args.importer) {
      const pathAlreadyHasExt = pathExtIsJsLikeExtension(args.path);
      const pathIsBuiltin = build.initialOptions.platform === "node" && await isBuiltin(args.path);
      const pathIsDependency = build.initialOptions.platform === "node" && await isDefinedDependency(args.path);
      if (!pathAlreadyHasExt && !pathIsBuiltin && !pathIsDependency) {
        let { path } = args;
        if (await isDirectory(args.resolveDir, path)) {
          path = `${path}/index`;
        }
        if (await isFile(args.resolveDir, path)) {
          return {
            path,
            external: true,
            namespace: options.namespace
          };
        }
        return {
          path: `${path}.${isEsm ? esmExtension : cjsExtension}`,
          external: true,
          namespace: options.namespace
        };
      }
    }
  }
  return void 0;
}
__name(handleResolve, "handleResolve");
var esbuildPluginFilePathExtensions = /* @__PURE__ */ __name((options = {
  filter: /.*/,
  cjsExtension: "cjs",
  esmExtension: "mjs"
}) => {
  const filter = getFilter(options);
  const { namespace } = options;
  return {
    name: "esbuild-plugin-file-path-extensions",
    setup(build) {
      build.onResolve({ filter, namespace }, (args) => handleResolve(args, build, options));
    }
  };
}, "esbuildPluginFilePathExtensions");
var version = "2.1.4";

export { esbuildPluginFilePathExtensions, version };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map